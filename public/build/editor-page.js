/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\n__webpack_require__(1);\n\nangular.module(\"editor-page\", [\"timed-review\"]);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./run/editor-page.js\n ** module id = 0\n ** module chunks = 4\n **/\n//# sourceURL=webpack:///./run/editor-page.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = __webpack_require__(4)[\"default\"];\n\nvar SimpleDirective = _interopRequire(__webpack_require__(5));\n\nvar Conversation = _interopRequire(__webpack_require__(6));\n\nvar DialogItem = _interopRequire(__webpack_require__(7));\n\n__webpack_require__(12);\n\nfunction iPromised($q, data) {\n  var p = $q.defer();\n  p.resolve(data);\n  return p.promise;\n}\n\nmodule.exports = angular.module(\"timed-review\", []).controller(\"TimedReviewController\", function ($scope, $rootScope, TimedReview) {\n  $scope.onDone = function (data) {\n    alert(\"finished\");\n  };\n\n  $scope.reviewId = $rootScope.$stateParams.contentId;\n\n  TimedReview.get({ contentId: $scope.reviewId }, function (data) {\n    $scope.reviewData = data.reviewData;\n    $scope.timeLimit = data.timed_limit;\n    $scope.pauseDuration = data.timed_pause;\n    $rootScope.pagename = data.title\n    // $rootScope.$digest()\n    ;\n  });\n\n  $scope.submitResults = function (recorded, done) {\n    var data = new FormData();\n    data.append(\"chunks\", recorded.length);\n    for (var i = 0; i < recorded.length; i++) {\n      data.append(\"chunk-\" + i + \"-audio\", recorded[i].audio);\n      data.append(\"chunk-\" + i + \"-video\", recorded[i].video);\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.responseType = \"json\";\n    xhr.addEventListener(\"load\", function (evt) {\n      if (xhr.response !== \"success\") {\n        console.log(\"bad response saving timed review\", xhr.response);\n        return done(new Error(\"failed to save\"));\n      }\n      console.log(\"done!\", xhr.response);\n      done();\n    });\n    xhr.open(\"POST\", \"/timed_review/\" + $scope.reviewId + \"/post\");\n    xhr.send(data);\n  };\n}).directive(\"timedReview\", function timedReview() {\n  return {\n    scope: { conversation: \"=timedReview\", onDone: \"=\", timeLimit: \"=\", pauseDuration: \"=\" },\n    templateUrl: \"/public/views/timed-review/conversation.html\",\n    controller: __webpack_require__(8)\n  };\n}).directive(\"timerCircle\", __webpack_require__(9)).directive(\"dialogItem\", function dialogItem() {\n  return {\n    scope: {\n      // pastItems: '=',\n      data: \"=\",\n      onDone: \"=\",\n      onData: \"=\",\n      stream: \"=\",\n      timeLimit: \"=\",\n      pauseDuration: \"=\" },\n    templateUrl: \"/public/views/timed-review/dialog-item.html\",\n    controller: function controller($scope, $element, $sce) {\n      $scope.$watch(\"data\", function (data) {\n        // $scope.dialog = new DialogItem(data, $scope.stream, $scope.time, $scope.$digest.bind($scope));\n        $scope.dialog = new DialogItem({\n          data: $scope.data,\n          stream: $scope.stream,\n          timeLimit: $scope.timeLimit,\n          pauseDuration: $scope.pauseDuration,\n          onUpdate: $scope.$digest.bind($scope),\n          onData: $scope.onData });\n      });\n      $scope.$watch(\"stream\", function (stream) {\n        $scope.dialog.stream = stream;\n        $scope.previewUrl = $sce.trustAsResourceUrl(window.URL.createObjectURL(stream));\n      });\n      $scope.$watch(\"dialog.state\", function (state) {\n        if (state === \"started\") {\n          $element.find(\"video\")[0].play();\n        } else {\n          $element.find(\"video\")[0].pause();\n        }\n      });\n      $element.find(\"video\")[0].muted = true;\n      $scope.$on(\"$destroy\", function () {\n        $scope.dialog.stop();\n      });\n    } };\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/index.js\n ** module id = 1\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/index.js?");

/***/ },
/* 2 */,
/* 3 */,
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nexports[\"default\"] = function (obj) {\n  return obj && obj.__esModule ? obj[\"default\"] : obj;\n};\n\nexports.__esModule = true;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require.js\n ** module id = 4\n ** module chunks = 0 1 3 4\n **/\n//# sourceURL=webpack:///./~/babel-runtime/helpers/interop-require.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nmodule.exports = function (controller, template) {\n  return [\"$compile\", function SimpleDirective($compile) {\n    return {\n      scope: {},\n      template: template,\n      controller: controller };\n  }];\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/lib/simple-directive.js\n ** module id = 5\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/lib/simple-directive.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar DialogItem = __webpack_require__(7);\n\n/*let getUserMedia = (function() {\r\n\tnavigator.getUserMedia.bind(navigator) ||\r\n\tnavigator.webkitGetUserMedia.bind(navigator)  || \r\n                          navigator.mozGetUserMedia.bind(navigator) || \r\n                          navigator.msGetUserMedia.bind(navigator)\r\n})();\r\n*/\nvar mediaNoBinding = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\nif (mediaNoBinding) {\n  var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia).bind(navigator);\n}\n\nmodule.exports = Conversation;\n\nfunction Conversation(data, onUpdated, onDone) {\n  this.dialog = data;\n  this.state = \"unstarted\";\n  this.index = 0;\n  this.length = this.dialog.length;\n  this.onUpdated = onUpdated;\n  this.onDone = onDone;\n  // this.dialogs = data.dialog.map(function (data) {return new DialogItem(data)})\n  this.score = 0;\n  this.next = this.next.bind(this);\n  this.onData = this.onData.bind(this);\n  // this.state = 'finished'\n  this.recorded = [];\n  this.start();\n}\n\nConversation.prototype = {\n  start: function start(speed) {\n    this.state = \"starting\";\n    this.speed = speed;\n\n    getUserMedia({ audio: true, video: true }, this.onStarted.bind(this), (function onError(error) {\n      this.state = \"error\";\n      this.error = error;\n      this.onUpdated();\n    }).bind(this));\n  },\n\n  onStarted: function onStarted(stream) {\n    this.mediaStream = stream;\n    this.state = \"running\";\n    this.index = 0;\n    this.score = 0;\n    this.onUpdated();\n  },\n\n  getCurrentDialog: function getCurrentDialog() {\n    return this.dialog[this.index];\n  },\n\n  next: function next() {\n    this.score += 1;\n    if (this.index < this.length - 1) {\n      this.index += 1;\n    } else {\n      this.end();\n    }\n    try {\n      this.onUpdated();\n    } catch (e) {}\n  },\n\n  onData: function onData(audio, video) {\n    this.recorded[this.index] = { audio: audio, video: video };\n  },\n\n  submitVideos: function submitVideos(done) {\n    this.onDone(this.recorded, done);\n  },\n\n  end: function end() {\n    var _this = this;\n\n    if (this.state === \"finished\") {\n      return;\n    }this.state = \"finishing\";\n    this.mediaStream.stop();\n    this.submitVideos(function (error) {\n      _this.state = error ? \"upload-error\" : \"finished\";\n      _this.onUpdated();\n    });\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/lib/conversation.js\n ** module id = 6\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/lib/conversation.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar startSpeech = __webpack_require__(17),\n    recorder = __webpack_require__(18);\n\nmodule.exports = DialogItem;\n\nfunction DialogItem(_ref) {\n  var data = _ref.data;\n  var stream = _ref.stream;\n  var pauseDuration = _ref.pauseDuration;\n  var timeLimit = _ref.timeLimit;\n  var onUpdate = _ref.onUpdate;\n  var onData = _ref.onData;\n\n  this.data = data;\n  this.stream = stream;\n  this.finalWords = [];\n  this.interimWords = [];\n  this.onUpdate = onUpdate;\n  this.onData = onData;\n  this.state = \"prompt\";\n  // this.start()\n  this.onStart = (function () {\n    this.start();\n    this.onUpdate();\n  }).bind(this);\n  this.start = this.start.bind(this);\n  this.stop = this.stop.bind(this);\n  this.promptAudio = \"/public/coursecontent/timed-review/audio/\" + data.prompt_audio;\n  this.answerAudio = \"/public/coursecontent/timed-review/audio/\" + data.answer_audio;\n  this.promptTime = pauseDuration; // data.prompt_duration\n  if (timeLimit) {\n    this.isTimed = true;\n    this.timeLimit = timeLimit // data.answer_duration * time\n    ;\n  }\n}\n\nDialogItem.prototype = {\n  start: function start() {\n    // this.startRecognizing()\n    this.state = \"starting\";\n    this.startRecording();\n  },\n\n  stop: function stop() {\n    if (this.state !== \"started\") {\n      return;\n    }this.state = \"processing\";\n    try {\n      this.onUpdate();\n    } catch (e) {}\n    // this.rec.stop()\n    this.stopRecording(this.doneRecording.bind(this));\n  },\n\n  doneRecording: function doneRecording(err, _ref) {\n    var audio = _ref.audio;\n    var video = _ref.video;\n\n    this.onData(audio, video);\n    this.validate();\n    this.onUpdate();\n  },\n\n  startRecording: function startRecording() {\n    this.stopRecording = recorder(this.stream, (function () {\n      console.log(\"started\");\n      this.state = \"started\";\n      this.onUpdate();\n    }).bind(this));\n  },\n\n  /** disabled for now\r\n  startRecognizing: function () {\r\n    this.rec = startSpeech({\r\n      start: function () {\r\n        this.state = 'started'\r\n        this.finalWords = []\r\n        this.interimWords = []\r\n        this.onUpdate()\r\n      }.bind(this),\r\n      error: function (error) {\r\n        this.state = 'error'\r\n        this.error = error\r\n        this.onUpdate()\r\n      }.bind(this),\r\n      result: function (results, index) {\r\n        this.interimWords = []\r\n        for (var i=index; i<results.length; ++i) {\r\n          if (results[i].isFinal) {\r\n            this.finalWords.push(results[i][0].transcript)\r\n          } else {\r\n            this.interimWords.push(results[i][0].transcript)\r\n          }\r\n        }\r\n        this.onUpdate()\r\n      }.bind(this),\r\n      end: function () {\r\n        // TODO make this better - is there some infos to send back?\r\n        // this.validate()\r\n        // this.onUpdate()\r\n      }.bind(this),\r\n    })\r\n  },\r\n  */\n\n  validate: function validate() {\n    console.log(\"done\");\n    this.state = \"done-valid\";\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/lib/dialog-item.js\n ** module id = 7\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/lib/dialog-item.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar Conversation = __webpack_require__(6);\n\nmodule.exports = function ($scope, $sce) {\n  var conversation = $scope.conversation;\n  $scope.game = new Conversation(conversation, update, $scope.onDone);\n\n  $scope.$on(\"$destroy\", function () {\n    $scope.game.end();\n  });\n\n  if (localStorage.DEBUG_CONVERSE) {\n    $scope.game.start();\n  }\n\n  function update() {\n    if (!$scope.$$phase) {\n      try {\n        $scope.$digest();\n      } catch (e) {}\n    }\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/controllers/conversation.js\n ** module id = 8\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/controllers/conversation.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nfunction pie(x, y, t1, r) {\n  var vals = {\n    x1: Math.cos(0) * r + x,\n    y1: Math.sin(0) * r + y,\n    x2: Math.cos(t1) * r + x,\n    y2: Math.sin(t1) * r + y,\n    flag: t1 < Math.PI ? 0 : 1,\n    r: r };\n  return \"M${x1} ${y1} A ${r} ${r}, 0, ${flag}, 1, ${x2} ${y2}\".replace(/\\${([^}]+)}/g, function (full, name) {\n    return vals[name];\n  });\n}\n\nmodule.exports = function timerDirective() {\n  return {\n    scope: {\n      onDone: \"=\",\n      time: \"=\"\n    },\n\n    template: \"<div class=\\\"Timer\\\">\" + \"<svg width=100 height=100>\" + \"<circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"40\\\"/>\" + \"<path ng-attr-d=\\\"{{path}}\\\"/>\" + \"</svg>\" + \"</div>\",\n    controller: function controller($scope) {\n      $scope.start = Date.now();\n      $scope.left = $scope.time;\n      function makePie() {\n        return pie(50, 50, (Date.now() - $scope.start) / 1000 / $scope.time * Math.PI * 2, 40);\n      }\n      $scope.path = makePie();\n      var tout = setInterval(function () {\n        $scope.left = $scope.time - (Date.now() - $scope.start) / 1000;\n        if ($scope.left <= 0) {\n          $scope.left = 0;\n          clearInterval(tout);\n          $scope.onDone();\n        } else {\n          $scope.path = makePie();\n        }\n        $scope.$digest();\n      }, 20);\n\n      $scope.$on(\"$destroy\", function () {\n        clearInterval(tout);\n      });\n    } };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/lib/timer.js\n ** module id = 9\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/lib/timer.js?");

/***/ },
/* 10 */,
/* 11 */,
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("// removed by extract-text-webpack-plugin\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/index.less\n ** module id = 12\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/index.less?");

/***/ },
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("// uses the webkitspeech\n\n\"use strict\";\n\nmodule.exports = function (options) {\n  var rec = new webkitSpeechRecognition();\n  rec.interimResults = false; // options.interim === false ? false : true\n  rec.continuous = true;\n  rec.onstart = options.start;\n  rec.onerror = options.error && function (evt) {\n    options.error(evt.error);\n  };\n  rec.onend = function () {\n    clearTimeout(timeout);\n    options.end.apply(this, arguments);\n  };\n  rec.onresult = options.result && function (evt) {\n    if (typeof evt.results === \"undefined\") {\n      return;\n    }\n    options.result([].slice.call(evt.results), evt.resultIndex);\n  };\n  rec.start();\n  if (options.timeout) {\n    var timeout = setTimeout(function () {\n      rec.stop();\n      options.end();\n    }, options.timeout);\n  }\n  return rec;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/lib/speech.js\n ** module id = 17\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/lib/speech.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar MediaStreamRecorder = __webpack_require__(31);\nvar WhammyRecorder = __webpack_require__(32);\nvar StereoRecorder = __webpack_require__(33);\nvar async = __webpack_require__(34);\n\nvar isChrome = !navigator.mozGetUserMedia;\n\n// TODO have a timeout here (a second or so), so if the Recorder instance\n// doesn't start up, we can show a helpful error message.\n\nmodule.exports = isChrome ? recordChrome : recordMoz;\n\nfunction recordChrome(stream, onStarted) {\n  var stereo = new StereoRecorder(stream);\n  var whammy = new WhammyRecorder(stream);\n  stereo.record();\n  stereo.onAudioProcessStarted = function () {\n    whammy.record();\n    onStarted();\n  };\n  return function stop(done) {\n    async.parallel({\n      video: function video(next) {\n        whammy.stop(function () {\n          next(null, whammy.blob);\n        });\n      },\n      audio: function audio(next) {\n        stereo.stop(function () {\n          next(null, stereo.blob);\n        });\n      } }, function (err, blobs) {\n      done(null, blobs);\n    });\n  };\n}\n\nfunction recordMoz(stream, onStarted) {\n  var recorder = new MediaStreamRecorder(stream);\n  recorder.record();\n  stereo.onAudioProcessStarted = function () {\n    onStarted();\n  };\n  return function stop(done) {\n    recorder.stop(function () {\n      done(null, recorder.blob);\n    });\n  };\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./timed-review/lib/recnew.js\n ** module id = 18\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./timed-review/lib/recnew.js?");

/***/ },
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("// ______________________\r\n// MediaStreamRecorder.js\r\n\r\n// todo: need to show alert boxes for incompatible cases\r\n// encoder only supports 48k/16k mono audio channel\r\n\r\n/*\r\n * Implementation of https://dvcs.w3.org/hg/dap/raw-file/default/media-stream-capture/MediaRecorder.html\r\n * The MediaRecorder accepts a mediaStream as input source passed from UA. When recorder starts,\r\n * a MediaEncoder will be created and accept the mediaStream as input source.\r\n * Encoder will get the raw data by track data changes, encode it by selected MIME Type, then store the encoded in EncodedBufferCache object.\r\n * The encoded data will be extracted on every timeslice passed from Start function call or by RequestData function.\r\n * Thread model:\r\n * When the recorder starts, it creates a \"Media Encoder\" thread to read data from MediaEncoder object and store buffer in EncodedBufferCache object.\r\n * Also extract the encoded data and create blobs on every timeslice passed from start function or RequestData function called by UA.\r\n */\r\n\r\n/**\r\n * MediaStreamRecorder is an abstraction layer for \"MediaRecorder API\". It is used by {@link RecordRTC} to record MediaStream(s) in Firefox.\r\n * @summary Runs top over MediaRecorder API.\r\n * @typedef MediaStreamRecorder\r\n * @class\r\n * @example\r\n * var recorder = new MediaStreamRecorder(MediaStream);\r\n * recorder.mimeType = 'video/webm'; // audio/ogg or video/webm\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n *\r\n *     // or\r\n *     var blob = recorder.blob;\r\n * });\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n */\r\n\r\nmodule.exports = MediaStreamRecorder\r\n\r\nfunction MediaStreamRecorder(mediaStream) {\r\n    var self = this;\r\n\r\n    // if user chosen only audio option; and he tried to pass MediaStream with\r\n    // both audio and video tracks;\r\n    // using a dirty workaround to generate audio-only stream so that we can get audio/ogg output.\r\n    if (self.mimeType && self.mimeType !== 'video/webm' && mediaStream.getVideoTracks && mediaStream.getVideoTracks().length) {\r\n        var context = new AudioContext();\r\n        var mediaStreamSource = context.createMediaStreamSource(mediaStream);\r\n\r\n        var destination = context.createMediaStreamDestination();\r\n        mediaStreamSource.connect(destination);\r\n\r\n        mediaStream = destination.stream;\r\n    }\r\n\r\n    var dataAvailable = false;\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        // http://dxr.mozilla.org/mozilla-central/source/content/media/MediaRecorder.cpp\r\n        // https://wiki.mozilla.org/Gecko:MediaRecorder\r\n        // https://dvcs.w3.org/hg/dap/raw-file/default/media-stream-capture/MediaRecorder.html\r\n\r\n        // starting a recording session; which will initiate \"Reading Thread\"\r\n        // \"Reading Thread\" are used to prevent main-thread blocking scenarios\r\n        mediaRecorder = new window.MediaRecorder(mediaStream);\r\n\r\n        // Dispatching OnDataAvailable Handler\r\n        mediaRecorder.ondataavailable = function(e) {\r\n            if (dataAvailable) {\r\n                return;\r\n            }\r\n\r\n            if (!e.data.size) {\r\n                if (!self.disableLogs) {\r\n                    console.warn('Recording of', e.data.type, 'failed.');\r\n                }\r\n                return;\r\n            }\r\n\r\n            dataAvailable = true;\r\n\r\n            /**\r\n             * @property {Blob} blob - Recorded frames in video/webm blob.\r\n             * @memberof MediaStreamRecorder\r\n             * @example\r\n             * recorder.stop(function() {\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */\r\n            self.blob = new Blob([e.data], {\r\n                type: e.data.type || self.mimeType || 'audio/ogg'\r\n            });\r\n\r\n            if (self.callback) {\r\n                self.callback();\r\n            }\r\n        };\r\n\r\n        mediaRecorder.onerror = function(error) {\r\n            if (!self.disableLogs) {\r\n                console.warn(error);\r\n            }\r\n\r\n            // When the stream is \"ended\" set recording to 'inactive' \r\n            // and stop gathering data. Callers should not rely on \r\n            // exactness of the timeSlice value, especially \r\n            // if the timeSlice value is small. Callers should \r\n            // consider timeSlice as a minimum value\r\n\r\n            mediaRecorder.stop();\r\n            self.record(0);\r\n        };\r\n\r\n        // void start(optional long mTimeSlice)\r\n        // The interval of passing encoded data from EncodedBufferCache to onDataAvailable\r\n        // handler. \"mTimeSlice < 0\" means Session object does not push encoded data to\r\n        // onDataAvailable, instead, it passive wait the client side pull encoded data\r\n        // by calling requestData API.\r\n        mediaRecorder.start(0);\r\n\r\n        // Start recording. If timeSlice has been provided, mediaRecorder will\r\n        // raise a dataavailable event containing the Blob of collected data on every timeSlice milliseconds.\r\n        // If timeSlice isn't provided, UA should call the RequestData to obtain the Blob data, also set the mTimeSlice to zero.\r\n\r\n        if (self.onAudioProcessStarted) {\r\n            self.onAudioProcessStarted();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        this.callback = callback;\r\n        // mediaRecorder.state === 'recording' means that media recorder is associated with \"session\"\r\n        // mediaRecorder.state === 'stopped' means that media recorder is detached from the \"session\" ... in this case; \"session\" will also be deleted.\r\n\r\n        if (mediaRecorder.state === 'recording') {\r\n            // \"stop\" method auto invokes \"requestData\"!\r\n            // mediaRecorder.requestData();\r\n            mediaRecorder.stop();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (mediaRecorder.state === 'recording') {\r\n            mediaRecorder.pause();\r\n\r\n            if (!this.disableLogs) {\r\n                console.debug('Paused recording.');\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (mediaRecorder.state === 'paused') {\r\n            mediaRecorder.resume();\r\n\r\n            if (!this.disableLogs) {\r\n                console.debug('Resumed recording.');\r\n            }\r\n        }\r\n    };\r\n\r\n    // Reference to \"MediaRecorder\" object\r\n    var mediaRecorder;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/RecordRTC/MediaStreamRecorder.js\n ** module id = 31\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/RecordRTC/MediaStreamRecorder.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("// _________________\r\n// WhammyRecorder.js\r\n\r\n/**\r\n * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.\r\n * @summary Video recording feature in Chrome.\r\n * @typedef WhammyRecorder\r\n * @class\r\n * @example\r\n * var recorder = new WhammyRecorder(mediaStream);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n */\r\n\r\nvar Whammy = __webpack_require__(35)\r\n\r\nmodule.exports = WhammyRecorder\r\n\r\nfunction WhammyRecorder(mediaStream) {\r\n    /**\r\n     * This method records video.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        if (!this.width) {\r\n            this.width = 320;\r\n        }\r\n\r\n        if (!this.height) {\r\n            this.height = 240;\r\n        }\r\n\r\n        if (!this.video) {\r\n            this.video = {\r\n                width: this.width,\r\n                height: this.height\r\n            };\r\n        }\r\n\r\n        if (!this.canvas) {\r\n            this.canvas = {\r\n                width: this.width,\r\n                height: this.height\r\n            };\r\n        }\r\n\r\n        canvas.width = this.canvas.width;\r\n        canvas.height = this.canvas.height;\r\n\r\n        context = canvas.getContext('2d');\r\n\r\n        // setting defaults\r\n        if (this.video && this.video instanceof HTMLVideoElement) {\r\n            video = this.video.cloneNode();\r\n        } else {\r\n            video = document.createElement('video');\r\n            video.src = URL.createObjectURL(mediaStream);\r\n\r\n            video.width = this.video.width;\r\n            video.height = this.video.height;\r\n        }\r\n\r\n        video.muted = true;\r\n        video.play();\r\n\r\n        lastTime = new Date().getTime();\r\n        whammy = new Whammy.Video();\r\n\r\n        if (!this.disableLogs) {\r\n            console.log('canvas resolutions', canvas.width, '*', canvas.height);\r\n            console.log('video width/height', video.width || canvas.width, '*', video.height || canvas.height);\r\n        }\r\n\r\n        drawFrames();\r\n    };\r\n\r\n    function drawFrames() {\r\n        var duration = new Date().getTime() - lastTime;\r\n        if (!duration) {\r\n            return setTimeout(drawFrames, 10);\r\n        }\r\n\r\n        if (isPausedRecording) {\r\n            lastTime = new Date().getTime();\r\n            return setTimeout(drawFrames, 100);\r\n        }\r\n\r\n        // via #206, by Jack i.e. @Seymourr\r\n        lastTime = new Date().getTime();\r\n\r\n        if (video.paused) {\r\n            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\r\n            // Tweak for Android Chrome\r\n            video.play();\r\n        }\r\n\r\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n        whammy.frames.push({\r\n            duration: duration,\r\n            image: canvas.toDataURL('image/webp')\r\n        });\r\n\r\n        if (!isStopDrawing) {\r\n            setTimeout(drawFrames, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * remove black frames from the beginning to the specified frame\r\n     * @param {Array} _frames - array of frames to be checked\r\n     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)\r\n     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all\r\n     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all\r\n     * @returns {Array} - array of frames\r\n     */\r\n    // pull#293 by @volodalexey\r\n    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance) {\r\n        var localCanvas = document.createElement('canvas');\r\n        localCanvas.width = canvas.width;\r\n        localCanvas.height = canvas.height;\r\n        var context2d = localCanvas.getContext('2d');\r\n        var resultFrames = [];\r\n\r\n        var checkUntilNotBlack = _framesToCheck === -1;\r\n        var endCheckFrame = (_framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length) ?\r\n            _framesToCheck : _frames.length;\r\n        var sampleColor = {\r\n            r: 0,\r\n            g: 0,\r\n            b: 0\r\n        };\r\n        var maxColorDifference = Math.sqrt(\r\n            Math.pow(255, 2) +\r\n            Math.pow(255, 2) +\r\n            Math.pow(255, 2)\r\n        );\r\n        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;\r\n        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;\r\n        var doNotCheckNext = false;\r\n\r\n        for (var f = 0; f < endCheckFrame; f++) {\r\n            var matchPixCount, endPixCheck, maxPixCount;\r\n\r\n            if (!doNotCheckNext) {\r\n                var image = new Image();\r\n                image.src = _frames[f].image;\r\n                context2d.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n                var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);\r\n                matchPixCount = 0;\r\n                endPixCheck = imageData.data.length;\r\n                maxPixCount = imageData.data.length / 4;\r\n\r\n                for (var pix = 0; pix < endPixCheck; pix += 4) {\r\n                    var currentColor = {\r\n                        r: imageData.data[pix],\r\n                        g: imageData.data[pix + 1],\r\n                        b: imageData.data[pix + 2]\r\n                    };\r\n                    var colorDifference = Math.sqrt(\r\n                        Math.pow(currentColor.r - sampleColor.r, 2) +\r\n                        Math.pow(currentColor.g - sampleColor.g, 2) +\r\n                        Math.pow(currentColor.b - sampleColor.b, 2)\r\n                    );\r\n                    // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)\r\n                    if (colorDifference <= maxColorDifference * pixTolerance) {\r\n                        matchPixCount++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {\r\n                // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);\r\n            } else {\r\n                // console.log('frame is passed : ' + f);\r\n                if (checkUntilNotBlack) {\r\n                    doNotCheckNext = true;\r\n                }\r\n                resultFrames.push(_frames[f]);\r\n            }\r\n        }\r\n\r\n        resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));\r\n\r\n        if (resultFrames.length <= 0) {\r\n            // at least one last frame should be available for next manipulation\r\n            // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...\r\n            resultFrames.push(_frames[_frames.length - 1]);\r\n        }\r\n\r\n        return resultFrames;\r\n    }\r\n\r\n    var isStopDrawing = false;\r\n\r\n    /**\r\n     * This method stops recording video.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        isStopDrawing = true;\r\n\r\n        var _this = this;\r\n        // analyse of all frames takes some time!\r\n        setTimeout(function() {\r\n            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames\r\n            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames\r\n            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color\r\n            whammy.frames = dropBlackFrames(whammy.frames, -1);\r\n\r\n            // to display advertisement images!\r\n            if (this.advertisement && this.advertisement.length) {\r\n                whammy.frames = this.advertisement.concat(whammy.frames);\r\n            }\r\n\r\n            /**\r\n             * @property {Blob} blob - Recorded frames in video/webm blob.\r\n             * @memberof WhammyRecorder\r\n             * @example\r\n             * recorder.stop(function() {\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */\r\n            whammy.compile(function(blob) {\r\n                _this.blob = blob;\r\n\r\n                if (_this.blob.forEach) {\r\n                    _this.blob = new Blob([], {\r\n                        type: 'video/webm'\r\n                    });\r\n                }\r\n\r\n                if (callback) {\r\n                    callback(_this.blob);\r\n                }\r\n            });\r\n        }, 10);\r\n    };\r\n\r\n    var isPausedRecording = false;\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPausedRecording = true;\r\n\r\n        if (!this.disableLogs) {\r\n            console.debug('Paused recording.');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        isPausedRecording = false;\r\n\r\n        if (!this.disableLogs) {\r\n            console.debug('Resumed recording.');\r\n        }\r\n    };\r\n\r\n    var canvas = document.createElement('canvas');\r\n    var context = canvas.getContext('2d');\r\n\r\n    var video;\r\n    var lastTime;\r\n    var whammy;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/RecordRTC/WhammyRecorder.js\n ** module id = 32\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/RecordRTC/WhammyRecorder.js?");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("// _________________\r\n// StereoRecorder.js\r\n\r\n/**\r\n * StereoRecorder is a standalone class used by {@link RecordRTC} to bring audio-recording in chrome. It runs top over {@link StereoAudioRecorder}.\r\n * @summary JavaScript standalone object for stereo audio recording.\r\n * @typedef StereoRecorder\r\n * @class\r\n * @example\r\n * var recorder = new StereoRecorder(MediaStream);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n */\r\n\r\nvar StereoAudioRecorder = __webpack_require__(36)\r\n\r\nmodule.exports = StereoRecorder\r\n\r\nfunction StereoRecorder(mediaStream) {\r\n    var self = this;\r\n\r\n    // Reference to \"StereoAudioRecorder\" object\r\n    var mediaRecorder;\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof StereoRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        mediaRecorder = new StereoAudioRecorder(mediaStream, this);\r\n        mediaRecorder.onAudioProcessStarted = function() {\r\n            if (self.onAudioProcessStarted) {\r\n                self.onAudioProcessStarted();\r\n            }\r\n        };\r\n        mediaRecorder.record();\r\n    };\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof StereoRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        mediaRecorder.stop(function() {\r\n            for (var item in mediaRecorder) {\r\n                self[item] = mediaRecorder[item];\r\n            }\r\n\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof StereoRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        mediaRecorder.pause();\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof StereoRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        if (!mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        mediaRecorder.resume();\r\n    };\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/RecordRTC/StereoRecorder.js\n ** module id = 33\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/RecordRTC/StereoRecorder.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n/*jshint onevar: false, indent:4 */\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = function () {};\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = function () {};\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        }\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n                q.process();\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                q.process();\n            }\n        };\n        return q;\n    };\n    \n    async.priorityQueue = function (worker, concurrency) {\n        \n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        };\n        \n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n        \n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n              \n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n        \n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n        \n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n        \n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return async;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37), __webpack_require__(39).setImmediate))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/async/lib/async.js\n ** module id = 34\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/async/lib/async.js?");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("// https://github.com/antimatter15/whammy/blob/master/LICENSE\r\n// _________\r\n// Whammy.js\r\n\r\n// todo: Firefox now supports webp for webm containers!\r\n// their MediaRecorder implementation works well!\r\n// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?\r\n\r\n/**\r\n * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}\r\n * @summary A real time javascript webm encoder based on a canvas hack.\r\n * @typedef Whammy\r\n * @class\r\n * @example\r\n * var recorder = new Whammy().Video(15);\r\n * recorder.add(context || canvas || dataURL);\r\n * var output = recorder.compile();\r\n */\r\n\r\n// a more abstract-ish API\r\n\r\nvar whammyInWebWorker = __webpack_require__(38);\r\n\r\nmodule.exports = {\r\n    /**\r\n      * A more abstract-ish API.\r\n      * @method\r\n      * @memberof Whammy\r\n      * @example\r\n      * recorder = new Whammy().Video(0.8, 100);\r\n      * @param {?number} speed - 0.8\r\n      * @param {?number} quality - 100\r\n      */\r\n    Video: WhammyVideo\r\n};\r\n\r\nfunction WhammyVideo(duration) {\r\n    this.frames = [];\r\n    this.duration = duration || 1;\r\n    this.quality = 100;\r\n}\r\n\r\n/**\r\n  * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.\r\n  * @method\r\n  * @memberof Whammy\r\n  * @example\r\n  * recorder = new Whammy().Video(0.8, 100);\r\n  * recorder.add(canvas || context || 'image/webp');\r\n  * @param {string} frame - Canvas || Context || image/webp\r\n  * @param {number} duration - Stick a duration (in milliseconds)\r\n  */\r\nWhammyVideo.prototype.add = function(frame, duration) {\r\n    if ('canvas' in frame) { //CanvasRenderingContext2D\r\n        frame = frame.canvas;\r\n    }\r\n\r\n    if ('toDataURL' in frame) {\r\n        frame = frame.toDataURL('image/webp', this.quality);\r\n    }\r\n\r\n    if (!(/^data:image\\/webp;base64,/ig).test(frame)) {\r\n        throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';\r\n    }\r\n    this.frames.push({\r\n        image: frame,\r\n        duration: duration || this.duration\r\n    });\r\n};\r\n\r\nfunction processInWebWorker(_function) {\r\n    var blob = URL.createObjectURL(new Blob([_function.toString(),\r\n        'this.onmessage =  function (e) {' + _function.name + '(e.data);}'\r\n    ], {\r\n        type: 'application/javascript'\r\n    }));\r\n\r\n    var worker = new Worker(blob);\r\n    URL.revokeObjectURL(blob);\r\n    return worker;\r\n}\r\n\r\n/**\r\n  * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.\r\n  * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n  * @method\r\n  * @memberof Whammy\r\n  * @example\r\n  * recorder = new Whammy().Video(0.8, 100);\r\n  * recorder.compile(function(blob) {\r\n  *    // blob.size - blob.type\r\n  * });\r\n  */\r\nWhammyVideo.prototype.compile = function(callback) {\r\n    var webWorker = processInWebWorker(whammyInWebWorker);\r\n\r\n    webWorker.onmessage = function(event) {\r\n        if (event.data.error) {\r\n            console.error(event.data.error);\r\n            return;\r\n        }\r\n        callback(event.data);\r\n    };\r\n\r\n    webWorker.postMessage(this.frames);\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/RecordRTC/Whammy.js\n ** module id = 35\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/RecordRTC/Whammy.js?");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js\r\n// https://github.com/mattdiamond/Recorderjs#license-mit\r\n// ______________________\r\n// StereoAudioRecorder.js\r\n\r\n/**\r\n * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring \"stereo\" audio-recording in chrome.\r\n * @summary JavaScript standalone object for stereo audio recording.\r\n * @typedef StereoAudioRecorder\r\n * @class\r\n * @example\r\n * var recorder = new StereoAudioRecorder(MediaStream, {\r\n *     sampleRate: 44100,\r\n *     bufferSize: 4096\r\n * });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {sampleRate: 44100, bufferSize: 4096}\r\n */\r\n\r\nvar AudioContextConstructor = null;\r\nvar AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\nmodule.exports = StereoAudioRecorder\r\n\r\nvar __stereoAudioRecorderJavacriptNode;\r\n\r\nfunction StereoAudioRecorder(mediaStream, config) {\r\n    if (!mediaStream.getAudioTracks().length) {\r\n        throw 'Your stream has no audio tracks.';\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // variables\r\n    var leftchannel = [];\r\n    var rightchannel = [];\r\n    var recording = false;\r\n    var recordingLength = 0;\r\n\r\n    if (!AudioContextConstructor) {\r\n        AudioContextConstructor = new AudioContext();\r\n    }\r\n\r\n    var context = AudioContextConstructor;\r\n\r\n    // creates an audio node from the microphone incoming stream\r\n    var audioInput = context.createMediaStreamSource(mediaStream);\r\n\r\n    var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];\r\n\r\n    /**\r\n     * The sample rate (in sample-frames per second) at which the\r\n     * AudioContext handles audio. It is assumed that all AudioNodes\r\n     * in the context run at this rate. In making this assumption,\r\n     * sample-rate converters or \"varispeed\" processors are not supported\r\n     * in real-time processing.\r\n     * The sampleRate parameter describes the sample-rate of the\r\n     * linear PCM audio data in the buffer in sample-frames per second.\r\n     * An implementation must support sample-rates in at least\r\n     * the range 22050 to 96000.\r\n     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder = new StereoAudioRecorder(mediaStream, {\r\n     *     sampleRate: 44100\r\n     * });\r\n     */\r\n    var sampleRate = typeof config.sampleRate !== 'undefined' ? config.sampleRate : context.sampleRate || 44100;\r\n\r\n    if (sampleRate < 22050 || sampleRate > 96000) {\r\n        // Ref: http://stackoverflow.com/a/26303918/552182\r\n        if (!config.disableLogs) {\r\n            console.warn('sample-rate must be under range 22050 and 96000.');\r\n        }\r\n    }\r\n\r\n    if (context.createScriptProcessor) {\r\n        __stereoAudioRecorderJavacriptNode = context.createScriptProcessor(bufferSize, 2, 2);\r\n    } else if (context.createJavaScriptNode) {\r\n        __stereoAudioRecorderJavacriptNode = context.createJavaScriptNode(bufferSize, 2, 2);\r\n    } else {\r\n        throw 'WebAudio API has no support on this browser.';\r\n    }\r\n\r\n    window.audioProcess = __stereoAudioRecorderJavacriptNode\r\n\r\n    // connect the stream to the gain node\r\n    audioInput.connect(__stereoAudioRecorderJavacriptNode);\r\n\r\n    bufferSize = __stereoAudioRecorderJavacriptNode.bufferSize;\r\n\r\n    if (!config.disableLogs) {\r\n        console.log('sample-rate', sampleRate);\r\n        console.log('buffer-size', bufferSize);\r\n    }\r\n\r\n    /**\r\n     * From the spec: This value controls how frequently the audioprocess event is\r\n     * dispatched and how many sample-frames need to be processed each call.\r\n     * Lower values for buffer size will result in a lower (better) latency.\r\n     * Higher values will be necessary to avoid audio breakup and glitches\r\n     * The size of the buffer (in sample-frames) which needs to\r\n     * be processed each time onprocessaudio is called.\r\n     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\r\n     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder = new StereoAudioRecorder(mediaStream, {\r\n     *     bufferSize: 4096\r\n     * });\r\n     */\r\n\r\n    // \"0\" means, let chrome decide the most accurate buffer-size for current platform.\r\n    var bufferSize = typeof config.bufferSize === 'undefined' ? 4096 : config.bufferSize;\r\n\r\n    if (legalBufferValues.indexOf(bufferSize) === -1) {\r\n        if (!config.disableLogs) {\r\n            console.warn('Legal values for buffer-size are ' + JSON.stringify(legalBufferValues, null, '\\t'));\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */\r\n    this.record = function() {\r\n        // reset the buffers for the new recording\r\n        leftchannel.length = rightchannel.length = 0;\r\n        recordingLength = 0;\r\n\r\n        recording = true;\r\n    };\r\n\r\n\r\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */\r\n    this.stop = function(callback) {\r\n        // stop recording\r\n        recording = false;\r\n\r\n        // to make sure onaudioprocess stops firing\r\n        audioInput.disconnect();\r\n\r\n        mergeLeftRightBuffers({\r\n            sampleRate: sampleRate,\r\n            leftChannel: config.leftChannel,\r\n            leftBuffers: [leftchannel, recordingLength],\r\n            rightBuffers: [rightchannel, recordingLength]\r\n        }, function(buffer, view) {\r\n            /**\r\n             * @property {Blob} blob - The recorded blob object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */\r\n            self.blob = new Blob([view], {\r\n                type: 'audio/wav'\r\n            });\r\n\r\n            /**\r\n             * @property {ArrayBuffer} buffer - The recorded buffer object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var buffer = recorder.buffer;\r\n             * });\r\n             */\r\n            self.buffer = new ArrayBuffer(view);\r\n\r\n            /**\r\n             * @property {DataView} view - The recorded data-view object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var view = recorder.view;\r\n             * });\r\n             */\r\n            self.view = view;\r\n\r\n            self.sampleRate = sampleRate;\r\n            self.bufferSize = bufferSize;\r\n\r\n            // recorded audio length\r\n            self.length = recordingLength;\r\n\r\n            if (callback) {\r\n                callback();\r\n            }\r\n\r\n            isAudioProcessStarted = false;\r\n        });\r\n    };\r\n\r\n    var isPaused = false;\r\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */\r\n    this.pause = function() {\r\n        isPaused = true;\r\n\r\n        if (!config.disableLogs) {\r\n            console.debug('Paused recording.');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */\r\n    this.resume = function() {\r\n        isPaused = false;\r\n\r\n        if (!config.disableLogs) {\r\n            console.debug('Resumed recording.');\r\n        }\r\n    };\r\n\r\n    var isAudioProcessStarted = false;\r\n\r\n    __stereoAudioRecorderJavacriptNode.addEventListener('audioprocess', function(e) {\r\n        if (isPaused) {\r\n            return;\r\n        }\r\n\r\n        // if MediaStream().stop() or MediaStreamTrack.stop() is invoked.\r\n        if (mediaStream.ended) {\r\n            __stereoAudioRecorderJavacriptNode.onaudioprocess = function() {};\r\n            return;\r\n        }\r\n\r\n        if (!recording) {\r\n            audioInput.disconnect();\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * This method is called on \"onaudioprocess\" event's first invocation.\r\n         * @method {function} onAudioProcessStarted\r\n         * @memberof StereoAudioRecorder\r\n         * @example\r\n         * recorder.onAudioProcessStarted: function() { };\r\n         */\r\n        if (!isAudioProcessStarted) {\r\n            isAudioProcessStarted = true;\r\n            if (self.onAudioProcessStarted) {\r\n                self.onAudioProcessStarted();\r\n            }\r\n        }\r\n\r\n        var left = e.inputBuffer.getChannelData(0);\r\n        var right = e.inputBuffer.getChannelData(1);\r\n\r\n        // we clone the samples\r\n        leftchannel.push(new Float32Array(left));\r\n        rightchannel.push(new Float32Array(right));\r\n\r\n        recordingLength += bufferSize;\r\n    });\r\n\r\n    // to prevent self audio to be connected with speakers\r\n    __stereoAudioRecorderJavacriptNode.connect(context.destination);\r\n}\r\n\r\nfunction mergeLeftRightBuffers(config, callback) {\r\n    function mergeAudioBuffers(config) {\r\n        var leftBuffers = config.leftBuffers;\r\n        var rightBuffers = config.rightBuffers;\r\n        var sampleRate = config.sampleRate;\r\n\r\n        leftBuffers = mergeBuffers(leftBuffers[0], leftBuffers[1]);\r\n        rightBuffers = mergeBuffers(rightBuffers[0], rightBuffers[1]);\r\n\r\n        function mergeBuffers(channelBuffer, rLength) {\r\n            var result = new Float64Array(rLength);\r\n            var offset = 0;\r\n            var lng = channelBuffer.length;\r\n\r\n            for (var i = 0; i < lng; i++) {\r\n                var buffer = channelBuffer[i];\r\n                result.set(buffer, offset);\r\n                offset += buffer.length;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function interleave(leftChannel, rightChannel) {\r\n            var length = leftChannel.length + rightChannel.length;\r\n\r\n            var result = new Float64Array(length);\r\n\r\n            var inputIndex = 0;\r\n\r\n            for (var index = 0; index < length;) {\r\n                result[index++] = leftChannel[inputIndex];\r\n                result[index++] = rightChannel[inputIndex];\r\n                inputIndex++;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function writeUTFBytes(view, offset, string) {\r\n            var lng = string.length;\r\n            for (var i = 0; i < lng; i++) {\r\n                view.setUint8(offset + i, string.charCodeAt(i));\r\n            }\r\n        }\r\n\r\n        // interleave both channels together\r\n        var interleaved = interleave(leftBuffers, rightBuffers);\r\n\r\n        var interleavedLength = interleaved.length;\r\n\r\n        // create wav file\r\n        var resultingBufferLength = 44 + interleavedLength * 2;\r\n\r\n        var buffer = new ArrayBuffer(resultingBufferLength);\r\n\r\n        var view = new DataView(buffer);\r\n\r\n        // RIFF chunk descriptor/identifier \r\n        writeUTFBytes(view, 0, 'RIFF');\r\n\r\n        // RIFF chunk length\r\n        var blockAlign = 4;\r\n        view.setUint32(blockAlign, 44 + interleavedLength * 2, true);\r\n\r\n        // RIFF type \r\n        writeUTFBytes(view, 8, 'WAVE');\r\n\r\n        // format chunk identifier \r\n        // FMT sub-chunk\r\n        writeUTFBytes(view, 12, 'fmt ');\r\n\r\n        // format chunk length \r\n        view.setUint32(16, 16, true);\r\n\r\n        // sample format (raw)\r\n        view.setUint16(20, 1, true);\r\n\r\n        // stereo (2 channels)\r\n        view.setUint16(22, 2, true);\r\n\r\n        // sample rate \r\n        view.setUint32(24, sampleRate, true);\r\n\r\n        // byte rate (sample rate * block align)\r\n        view.setUint32(28, sampleRate * blockAlign, true);\r\n\r\n        // block align (channel count * bytes per sample) \r\n        view.setUint16(32, blockAlign, true);\r\n\r\n        // bits per sample \r\n        view.setUint16(34, 16, true);\r\n\r\n        // data sub-chunk\r\n        // data chunk identifier \r\n        writeUTFBytes(view, 36, 'data');\r\n\r\n        // data chunk length \r\n        view.setUint32(40, interleavedLength * 2, true);\r\n\r\n        // write the PCM samples\r\n        var offset = 44,\r\n            leftChannel;\r\n        for (var i = 0; i < interleavedLength; i++, offset += 2) {\r\n            var size = Math.max(-1, Math.min(1, interleaved[i]));\r\n            var currentChannel = size < 0 ? size * 32768 : size * 32767;\r\n\r\n            if (config.leftChannel) {\r\n                if (currentChannel !== leftChannel) {\r\n                    view.setInt16(offset, currentChannel, true);\r\n                }\r\n                leftChannel = currentChannel;\r\n            } else {\r\n                view.setInt16(offset, currentChannel, true);\r\n            }\r\n        }\r\n\r\n        postMessage({\r\n            buffer: buffer,\r\n            view: view\r\n        });\r\n    }\r\n    var webWorker = processInWebWorker(mergeAudioBuffers);\r\n\r\n    webWorker.onmessage = function(event) {\r\n        callback(event.data.buffer, event.data.view);\r\n    };\r\n\r\n    webWorker.postMessage(config);\r\n}\r\n\r\nfunction processInWebWorker(_function) {\r\n    var blob = URL.createObjectURL(new Blob([_function.toString(),\r\n        'this.onmessage =  function (e) {' + _function.name + '(e.data);}'\r\n    ], {\r\n        type: 'application/javascript'\r\n    }));\r\n\r\n    var worker = new Worker(blob);\r\n    URL.revokeObjectURL(blob);\r\n    return worker;\r\n}\r\n\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/RecordRTC/StereoAudioRecorder.js\n ** module id = 36\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/RecordRTC/StereoAudioRecorder.js?");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 37\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("\r\nmodule.exports = whammyInWebWorker\r\n\r\nfunction whammyInWebWorker(frames) {\r\n    function ArrayToWebM(frames) {\r\n        var info = checkFrames(frames);\r\n        if (!info) {\r\n            return [];\r\n        }\r\n\r\n        var clusterMaxDuration = 30000;\r\n\r\n        var EBML = [{\r\n            'id': 0x1a45dfa3, // EBML\r\n            'data': [{\r\n                'data': 1,\r\n                'id': 0x4286 // EBMLVersion\r\n            }, {\r\n                'data': 1,\r\n                'id': 0x42f7 // EBMLReadVersion\r\n            }, {\r\n                'data': 4,\r\n                'id': 0x42f2 // EBMLMaxIDLength\r\n            }, {\r\n                'data': 8,\r\n                'id': 0x42f3 // EBMLMaxSizeLength\r\n            }, {\r\n                'data': 'webm',\r\n                'id': 0x4282 // DocType\r\n            }, {\r\n                'data': 2,\r\n                'id': 0x4287 // DocTypeVersion\r\n            }, {\r\n                'data': 2,\r\n                'id': 0x4285 // DocTypeReadVersion\r\n            }]\r\n        }, {\r\n            'id': 0x18538067, // Segment\r\n            'data': [{\r\n                'id': 0x1549a966, // Info\r\n                'data': [{\r\n                    'data': 1e6, //do things in millisecs (num of nanosecs for duration scale)\r\n                    'id': 0x2ad7b1 // TimecodeScale\r\n                }, {\r\n                    'data': 'whammy',\r\n                    'id': 0x4d80 // MuxingApp\r\n                }, {\r\n                    'data': 'whammy',\r\n                    'id': 0x5741 // WritingApp\r\n                }, {\r\n                    'data': doubleToString(info.duration),\r\n                    'id': 0x4489 // Duration\r\n                }]\r\n            }, {\r\n                'id': 0x1654ae6b, // Tracks\r\n                'data': [{\r\n                    'id': 0xae, // TrackEntry\r\n                    'data': [{\r\n                        'data': 1,\r\n                        'id': 0xd7 // TrackNumber\r\n                    }, {\r\n                        'data': 1,\r\n                        'id': 0x73c5 // TrackUID\r\n                    }, {\r\n                        'data': 0,\r\n                        'id': 0x9c // FlagLacing\r\n                    }, {\r\n                        'data': 'und',\r\n                        'id': 0x22b59c // Language\r\n                    }, {\r\n                        'data': 'V_VP8',\r\n                        'id': 0x86 // CodecID\r\n                    }, {\r\n                        'data': 'VP8',\r\n                        'id': 0x258688 // CodecName\r\n                    }, {\r\n                        'data': 1,\r\n                        'id': 0x83 // TrackType\r\n                    }, {\r\n                        'id': 0xe0, // Video\r\n                        'data': [{\r\n                            'data': info.width,\r\n                            'id': 0xb0 // PixelWidth\r\n                        }, {\r\n                            'data': info.height,\r\n                            'id': 0xba // PixelHeight\r\n                        }]\r\n                    }]\r\n                }]\r\n            }]\r\n        }];\r\n\r\n        //Generate clusters (max duration)\r\n        var frameNumber = 0;\r\n        var clusterTimecode = 0;\r\n        while (frameNumber < frames.length) {\r\n\r\n            var clusterFrames = [];\r\n            var clusterDuration = 0;\r\n            do {\r\n                clusterFrames.push(frames[frameNumber]);\r\n                clusterDuration += frames[frameNumber].duration;\r\n                frameNumber++;\r\n            } while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);\r\n\r\n            var clusterCounter = 0;\r\n            var cluster = {\r\n                'id': 0x1f43b675, // Cluster\r\n                'data': getClusterData(clusterTimecode, clusterCounter, clusterFrames)\r\n            }; //Add cluster to segment\r\n            EBML[1].data.push(cluster);\r\n            clusterTimecode += clusterDuration;\r\n        }\r\n\r\n        return generateEBML(EBML);\r\n    }\r\n\r\n    function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {\r\n        return [{\r\n            'data': clusterTimecode,\r\n            'id': 0xe7 // Timecode\r\n        }].concat(clusterFrames.map(function(webp) {\r\n            var block = makeSimpleBlock({\r\n                discardable: 0,\r\n                frame: webp.data.slice(4),\r\n                invisible: 0,\r\n                keyframe: 1,\r\n                lacing: 0,\r\n                trackNum: 1,\r\n                timecode: Math.round(clusterCounter)\r\n            });\r\n            clusterCounter += webp.duration;\r\n            return {\r\n                data: block,\r\n                id: 0xa3\r\n            };\r\n        }));\r\n    }\r\n\r\n    // sums the lengths of all the frames and gets the duration\r\n\r\n    function checkFrames(frames) {\r\n        if (!frames[0]) {\r\n            postMessage({\r\n                error: 'Something went wrong. Maybe WebP format is not supported in the current browser.'\r\n            });\r\n            return;\r\n        }\r\n\r\n        var width = frames[0].width,\r\n            height = frames[0].height,\r\n            duration = frames[0].duration;\r\n\r\n        for (var i = 1; i < frames.length; i++) {\r\n            duration += frames[i].duration;\r\n        }\r\n        return {\r\n            duration: duration,\r\n            width: width,\r\n            height: height\r\n        };\r\n    }\r\n\r\n    function numToBuffer(num) {\r\n        var parts = [];\r\n        while (num > 0) {\r\n            parts.push(num & 0xff);\r\n            num = num >> 8;\r\n        }\r\n        return new Uint8Array(parts.reverse());\r\n    }\r\n\r\n    function strToBuffer(str) {\r\n        return new Uint8Array(str.split('').map(function(e) {\r\n            return e.charCodeAt(0);\r\n        }));\r\n    }\r\n\r\n    function bitsToBuffer(bits) {\r\n        var data = [];\r\n        var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\r\n        bits = pad + bits;\r\n        for (var i = 0; i < bits.length; i += 8) {\r\n            data.push(parseInt(bits.substr(i, 8), 2));\r\n        }\r\n        return new Uint8Array(data);\r\n    }\r\n\r\n    function generateEBML(json) {\r\n        var ebml = [];\r\n        for (var i = 0; i < json.length; i++) {\r\n            var data = json[i].data;\r\n\r\n            if (typeof data === 'object') {\r\n                data = generateEBML(data);\r\n            }\r\n\r\n            if (typeof data === 'number') {\r\n                data = bitsToBuffer(data.toString(2));\r\n            }\r\n\r\n            if (typeof data === 'string') {\r\n                data = strToBuffer(data);\r\n            }\r\n\r\n            var len = data.size || data.byteLength || data.length;\r\n            var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\r\n            var sizeToString = len.toString(2);\r\n            var padded = (new Array((zeroes * 7 + 7 + 1) - sizeToString.length)).join('0') + sizeToString;\r\n            var size = (new Array(zeroes)).join('0') + '1' + padded;\r\n\r\n            ebml.push(numToBuffer(json[i].id));\r\n            ebml.push(bitsToBuffer(size));\r\n            ebml.push(data);\r\n        }\r\n\r\n        return new Blob(ebml, {\r\n            type: 'video/webm'\r\n        });\r\n    }\r\n\r\n    function toBinStrOld(bits) {\r\n        var data = '';\r\n        var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\r\n        bits = pad + bits;\r\n        for (var i = 0; i < bits.length; i += 8) {\r\n            data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\r\n        }\r\n        return data;\r\n    }\r\n\r\n    function makeSimpleBlock(data) {\r\n        var flags = 0;\r\n\r\n        if (data.keyframe) {\r\n            flags |= 128;\r\n        }\r\n\r\n        if (data.invisible) {\r\n            flags |= 8;\r\n        }\r\n\r\n        if (data.lacing) {\r\n            flags |= (data.lacing << 1);\r\n        }\r\n\r\n        if (data.discardable) {\r\n            flags |= 1;\r\n        }\r\n\r\n        if (data.trackNum > 127) {\r\n            throw 'TrackNumber > 127 not supported';\r\n        }\r\n\r\n        var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function(e) {\r\n            return String.fromCharCode(e);\r\n        }).join('') + data.frame;\r\n\r\n        return out;\r\n    }\r\n\r\n    function parseWebP(riff) {\r\n        var VP8 = riff.RIFF[0].WEBP[0];\r\n\r\n        var frameStart = VP8.indexOf('\\x9d\\x01\\x2a'); // A VP8 keyframe starts with the 0x9d012a header\r\n        for (var i = 0, c = []; i < 4; i++) {\r\n            c[i] = VP8.charCodeAt(frameStart + 3 + i);\r\n        }\r\n\r\n        var width, height, tmp;\r\n\r\n        //the code below is literally copied verbatim from the bitstream spec\r\n        tmp = (c[1] << 8) | c[0];\r\n        width = tmp & 0x3FFF;\r\n        tmp = (c[3] << 8) | c[2];\r\n        height = tmp & 0x3FFF;\r\n        return {\r\n            width: width,\r\n            height: height,\r\n            data: VP8,\r\n            riff: riff\r\n        };\r\n    }\r\n\r\n    function getStrLength(string, offset) {\r\n        return parseInt(string.substr(offset + 4, 4).split('').map(function(i) {\r\n            var unpadded = i.charCodeAt(0).toString(2);\r\n            return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;\r\n        }).join(''), 2);\r\n    }\r\n\r\n    function parseRIFF(string) {\r\n        var offset = 0;\r\n        var chunks = {};\r\n\r\n        while (offset < string.length) {\r\n            var id = string.substr(offset, 4);\r\n            var len = getStrLength(string, offset);\r\n            var data = string.substr(offset + 4 + 4, len);\r\n            offset += 4 + 4 + len;\r\n            chunks[id] = chunks[id] || [];\r\n\r\n            if (id === 'RIFF' || id === 'LIST') {\r\n                chunks[id].push(parseRIFF(data));\r\n            } else {\r\n                chunks[id].push(data);\r\n            }\r\n        }\r\n        return chunks;\r\n    }\r\n\r\n    function doubleToString(num) {\r\n        return [].slice.call(\r\n            new Uint8Array((new Float64Array([num])).buffer), 0).map(function(e) {\r\n            return String.fromCharCode(e);\r\n        }).reverse().join('');\r\n    }\r\n\r\n    var webm = new ArrayToWebM(frames.map(function(frame) {\r\n        var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\r\n        webp.duration = frame.duration;\r\n        return webp;\r\n    }));\r\n\r\n    postMessage(webm);\r\n}\r\n\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/RecordRTC/whammy_worker.js\n ** module id = 38\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///./~/RecordRTC/whammy_worker.js?");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(37).nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(39).setImmediate, __webpack_require__(39).clearImmediate))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 39\n ** module chunks = 0 1 4\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js?");

/***/ }
/******/ ]);